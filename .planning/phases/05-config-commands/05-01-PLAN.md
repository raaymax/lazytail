---
phase: 05-config-commands
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/main.rs
  - src/cmd/mod.rs
  - src/cmd/init.rs
autonomous: true

must_haves:
  truths:
    - "lazytail init creates lazytail.yaml in current directory with commented examples"
    - "lazytail init creates .lazytail/ directory alongside config file"
    - "lazytail init fails with error if lazytail.yaml exists (without --force)"
    - "lazytail init --force overwrites existing config"
    - "lazytail file.log still works (backward compatibility)"
  artifacts:
    - path: "src/cmd/mod.rs"
      provides: "Subcommand enum and dispatch logic"
      exports: ["Commands", "InitArgs", "ConfigAction"]
    - path: "src/cmd/init.rs"
      provides: "Init command implementation"
      exports: ["run"]
  key_links:
    - from: "src/main.rs"
      to: "src/cmd/mod.rs"
      via: "Option<Commands> in Cli struct"
      pattern: "command:\\s*Option<Commands>"
    - from: "src/cmd/init.rs"
      to: "src/source.rs"
      via: "create_secure_dir for .lazytail/"
      pattern: "create_secure_dir"
---

<objective>
Create CLI subcommand infrastructure and implement the `lazytail init` command.

Purpose: Enable developer-friendly project initialization following `git init` / `npm init` patterns.
Output: Working `lazytail init` command that creates starter config and data directory.
</objective>

<execution_context>
@/home/raay/.claude/get-shit-done/workflows/execute-plan.md
@/home/raay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-config-commands/05-CONTEXT.md
@.planning/phases/05-config-commands/05-RESEARCH.md
@src/main.rs
@src/config/discovery.rs
@src/source.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add colored dependency and create cmd module structure</name>
  <files>Cargo.toml, src/cmd/mod.rs</files>
  <action>
1. Add colored dependency to Cargo.toml:
   ```
   colored = "2.7"
   ```

2. Create src/cmd/mod.rs with:
   - `pub mod init;` declaration
   - Clap-derived subcommand enums:
     - `Commands` enum with `Init(InitArgs)` and `Config { action: ConfigAction }` variants
     - `InitArgs` struct with `#[arg(long)] force: bool`
     - `ConfigAction` enum with `Validate` and `Show` variants
   - Re-export for use in main.rs

Use clap derive macros (`#[derive(Subcommand)]`, `#[derive(Args)]`).
Add doc comments for CLI help text:
- Init: "Initialize a new lazytail.yaml config file"
- Config: "Config file commands"
- Validate: "Validate the config file"
- Show: "Show effective configuration"
  </action>
  <verify>
cargo check compiles without errors
  </verify>
  <done>
cmd module exists with Commands, InitArgs, and ConfigAction types exported
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor main.rs for subcommand handling</name>
  <files>src/main.rs</files>
  <action>
1. Add `mod cmd;` to module declarations at top of file.

2. Update the `Args` struct (rename to `Cli` for clarity):
   - Add optional subcommand field:
     ```rust
     #[command(subcommand)]
     command: Option<cmd::Commands>,
     ```
   - Keep all existing fields (files, no_watch, name, mcp, verbose)

3. In main() function, after `Args::parse()` (now `Cli::parse()`):
   - Add subcommand dispatch BEFORE existing mode detection logic
   - Pattern:
     ```rust
     // Handle subcommands first (before mode detection)
     if let Some(command) = cli.command {
         return match command {
             cmd::Commands::Init(args) => {
                 cmd::init::run(args.force)
                     .map_err(|_| anyhow::anyhow!("init failed"))
             }
             cmd::Commands::Config { action } => {
                 match action {
                     cmd::ConfigAction::Validate => {
                         // TODO: Plan 05-02
                         Ok(())
                     }
                     cmd::ConfigAction::Show => {
                         // TODO: Plan 05-02
                         Ok(())
                     }
                 }
             }
         };
     }
     ```

4. Update all `args.` references to `cli.` throughout the file.

IMPORTANT: The existing file/stdin/discovery mode logic must remain unchanged and work when no subcommand is given. This preserves backward compatibility.
  </action>
  <verify>
cargo build succeeds
cargo run -- --help shows init and config subcommands
cargo run -- test.log (with a test file) still works as before
  </verify>
  <done>
main.rs handles subcommands with fallthrough to existing behavior when no subcommand given
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement init command</name>
  <files>src/cmd/init.rs</files>
  <action>
Create src/cmd/init.rs with `run(force: bool) -> Result<(), i32>` function:

1. Get current working directory with `std::env::current_dir()`

2. Build paths:
   - config_path = cwd.join(PROJECT_CONFIG_NAME)  // "lazytail.yaml"
   - data_dir = cwd.join(DATA_DIR_NAME)  // ".lazytail"
   Import constants from `crate::config::discovery::{PROJECT_CONFIG_NAME, DATA_DIR_NAME}`

3. Check for existing config:
   - If config_path.exists() && !force:
     - eprintln!("error: {} already exists", config_path.display())
     - eprintln!("hint: Use --force to overwrite")
     - return Err(1)

4. Auto-detect project name from directory:
   ```rust
   let project_name = cwd
       .file_name()
       .map(|n| n.to_string_lossy().to_string())
       .unwrap_or_else(|| "my-project".to_string());
   ```

5. Generate config content with template (per RESEARCH.md):
   ```rust
   fn write_config_template(project_name: &str) -> String {
       format!(
           r#"# lazytail.yaml - Log viewer configuration
# Generated by: lazytail init

# Project name (optional, defaults to directory name)
name: {project_name}

# Log sources to display in the viewer
# sources:
#   - name: api           # Display name shown in tabs
#     path: /var/log/api.log
#   - name: worker
#     path: ~/logs/worker.log
"#,
           project_name = project_name
       )
   }
   ```

6. Write config file:
   ```rust
   std::fs::write(&config_path, content).map_err(|e| {
       eprintln!("error: Failed to write config: {}", e);
       1
   })?;
   ```

7. Create .lazytail/ data directory using `crate::source::create_secure_dir`:
   ```rust
   source::create_secure_dir(&data_dir).map_err(|e| {
       eprintln!("error: Failed to create data directory: {}", e);
       1
   })?;
   ```

8. Success message:
   ```rust
   println!("Created {} and {}/", PROJECT_CONFIG_NAME, DATA_DIR_NAME);
   Ok(())
   ```

Import requirements at top:
- `use crate::config::discovery::{DATA_DIR_NAME, PROJECT_CONFIG_NAME};`
- `use crate::source;`
- `use std::path::PathBuf;`
  </action>
  <verify>
Create temp directory, run lazytail init, verify lazytail.yaml created with correct content
Run lazytail init again (without --force), verify it fails with error message
Run lazytail init --force, verify it succeeds and overwrites
Verify .lazytail/ directory is created
cargo test (existing tests still pass)
  </verify>
  <done>
lazytail init creates lazytail.yaml with commented template and .lazytail/ directory
lazytail init refuses to overwrite without --force flag
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build` succeeds
2. `cargo test` passes (no regressions)
3. `lazytail --help` shows init and config subcommands
4. `lazytail init` in empty directory creates lazytail.yaml + .lazytail/
5. `lazytail init` in directory with lazytail.yaml shows error
6. `lazytail init --force` overwrites existing config
7. `lazytail file.log` still works (backward compatibility preserved)
</verification>

<success_criteria>
- cmd/ module exists with subcommand infrastructure
- init command creates lazytail.yaml with helpful comments
- init command creates .lazytail/ directory with secure permissions
- init respects --force flag for overwrite
- Backward compatibility: existing CLI usage unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/05-config-commands/05-01-SUMMARY.md`
</output>
