---
phase: 05-config-commands
plan: 02
type: execute
wave: 1
depends_on: ["05-01"]
files_modified:
  - src/cmd/mod.rs
  - src/cmd/config.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "lazytail config validate with valid config exits 0 silently"
    - "lazytail config validate with invalid config exits 1 with error to stderr"
    - "lazytail config validate with no config exits 1 with 'No config found to validate'"
    - "lazytail config validate checks that source files exist"
    - "lazytail config show displays path then config content with colors"
    - "lazytail config show with no config shows default values"
  artifacts:
    - path: "src/cmd/config.rs"
      provides: "Validate and show command implementations"
      exports: ["validate", "show"]
  key_links:
    - from: "src/cmd/config.rs"
      to: "src/config/loader.rs"
      via: "load() for config loading"
      pattern: "config::load"
    - from: "src/cmd/config.rs"
      to: "src/config/discovery.rs"
      via: "discover() for finding config files"
      pattern: "config::discover"
    - from: "src/main.rs"
      to: "src/cmd/config.rs"
      via: "ConfigAction dispatch"
      pattern: "cmd::config::(validate|show)"
---

<objective>
Implement `lazytail config validate` and `lazytail config show` commands.

Purpose: Enable config introspection and validation for CI pipelines and developer debugging.
Output: Working validate and show commands following Unix conventions (quiet success, colored output).
</objective>

<execution_context>
@/home/raay/.claude/get-shit-done/workflows/execute-plan.md
@/home/raay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-config-commands/05-CONTEXT.md
@.planning/phases/05-config-commands/05-RESEARCH.md
@.planning/phases/05-config-commands/05-01-SUMMARY.md
@src/main.rs
@src/cmd/mod.rs
@src/config/mod.rs
@src/config/loader.rs
@src/config/discovery.rs
@src/config/types.rs
@src/config/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement config validate command</name>
  <files>src/cmd/config.rs, src/cmd/mod.rs</files>
  <action>
1. Create src/cmd/config.rs with `pub fn validate() -> Result<(), i32>`:

2. Implement "closest config wins" discovery:
   ```rust
   use crate::config;

   /// Get the effective config path (closest wins: project > global).
   fn effective_config_path() -> Option<std::path::PathBuf> {
       let discovery = config::discover();
       // Project config wins completely if it exists
       discovery.project_config.or(discovery.global_config)
   }
   ```

3. Implement validate():
   ```rust
   pub fn validate() -> Result<(), i32> {
       // Find config to validate
       let config_path = match effective_config_path() {
           Some(path) => path,
           None => {
               eprintln!("error: No config found to validate");
               return Err(1);
           }
       };

       // Load and validate config
       let discovery = config::discover();
       match config::load(&discovery) {
           Ok(cfg) => {
               // Check source file existence (per user decision)
               let mut has_errors = false;
               for source in cfg.project_sources.iter().chain(cfg.global_sources.iter()) {
                   if !source.exists {
                       eprintln!(
                           "error: Source '{}' file not found: {}",
                           source.name,
                           source.path.display()
                       );
                       has_errors = true;
                   }
               }
               if has_errors {
                   Err(1)
               } else {
                   // Quiet success - just exit 0
                   Ok(())
               }
           }
           Err(e) => {
               // Use existing Cargo-style error formatting
               eprintln!("{}", e);
               Err(1)
           }
       }
   }
   ```

4. Update src/cmd/mod.rs:
   - Add `pub mod config;` declaration
  </action>
  <verify>
Create valid lazytail.yaml, run `lazytail config validate`, verify exit 0 and no output
Create invalid lazytail.yaml (bad YAML syntax), run `lazytail config validate`, verify exit 1 with error
Create lazytail.yaml with non-existent source path, run validate, verify exit 1 with source error
Run in directory without config, verify "No config found to validate" message
  </verify>
  <done>
lazytail config validate exits 0 silently for valid config
lazytail config validate exits 1 with errors for invalid config or missing sources
lazytail config validate exits 1 with message when no config exists
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement config show command</name>
  <files>src/cmd/config.rs</files>
  <action>
Add `pub fn show() -> Result<(), i32>` to src/cmd/config.rs:

1. Import colored:
   ```rust
   use colored::Colorize;
   ```

2. Implement show():
   ```rust
   pub fn show() -> Result<(), i32> {
       let discovery = config::discover();
       let config_path = effective_config_path();

       // Load config (or use defaults if no config)
       let cfg = match config::load(&discovery) {
           Ok(c) => c,
           Err(e) => {
               eprintln!("{}", e);
               return Err(1);
           }
       };

       // Show which config is being used (or indicate defaults)
       match config_path {
           Some(path) => {
               println!("Using: {}", path.display().to_string().dimmed());
           }
           None => {
               println!("{}", "No config found. Using defaults.".dimmed());
           }
       }
       println!();

       // Show config content
       show_config(&cfg);

       Ok(())
   }

   fn show_config(cfg: &config::Config) {
       // Name
       if let Some(name) = &cfg.name {
           println!("{}: {}", "name".cyan(), name.green());
       } else {
           println!("{}: {}", "name".cyan(), "(not set)".dimmed());
       }

       // Project sources
       if !cfg.project_sources.is_empty() {
           println!();
           println!("{}:", "project_sources".cyan());
           for source in &cfg.project_sources {
               show_source(source);
           }
       }

       // Global sources
       if !cfg.global_sources.is_empty() {
           println!();
           println!("{}:", "global_sources".cyan());
           for source in &cfg.global_sources {
               show_source(source);
           }
       }

       // No sources message
       if cfg.project_sources.is_empty() && cfg.global_sources.is_empty() {
           println!();
           println!("{}", "(no sources defined)".dimmed());
       }
   }

   fn show_source(source: &config::Source) {
       let status = if source.exists {
           "".to_string()
       } else {
           " (not found)".red().to_string()
       };
       println!("  - {}: {}", "name".blue(), source.name.green());
       println!(
           "    {}: {}{}",
           "path".blue(),
           source.path.display().to_string().yellow(),
           status
       );
   }
   ```

Color scheme (per research, Claude's discretion):
- Keys: cyan for top-level, blue for nested
- Values: green for text, yellow for paths
- Errors/warnings: red
- Headers/placeholders: dimmed
  </action>
  <verify>
Create lazytail.yaml with name and sources, run `lazytail config show`, verify colored output
Run in directory without config, verify "No config found. Using defaults." message
Set NO_COLOR=1, run show, verify no ANSI codes in output
  </verify>
  <done>
lazytail config show displays path at top then formatted config
lazytail config show shows defaults message when no config exists
Colored output respects NO_COLOR environment variable
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire up config subcommands in main.rs</name>
  <files>src/main.rs</files>
  <action>
Update the subcommand dispatch in main.rs to call the actual implementations:

Replace the TODO placeholders from Plan 05-01 with:
```rust
cmd::Commands::Config { action } => {
    match action {
        cmd::ConfigAction::Validate => {
            cmd::config::validate()
                .map_err(|code| {
                    std::process::exit(code);
                })
        }
        cmd::ConfigAction::Show => {
            cmd::config::show()
                .map_err(|code| {
                    std::process::exit(code);
                })
        }
    }
}
```

Note: The pattern `map_err(|code| std::process::exit(code))` ensures correct exit codes without returning an error to main's Result type.
  </action>
  <verify>
cargo build succeeds
lazytail config validate works end-to-end
lazytail config show works end-to-end
  </verify>
  <done>
Config subcommands are fully wired and functional
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `cargo build` succeeds
2. `cargo test` passes (no regressions)
3. `cargo clippy` passes
4. `lazytail config validate`:
   - With valid config: exit 0, no output
   - With invalid YAML: exit 1, error message to stderr
   - With missing source files: exit 1, source errors to stderr
   - With no config: exit 1, "No config found to validate"
5. `lazytail config show`:
   - With config: shows "Using: path" then formatted config
   - Without config: shows "No config found. Using defaults."
   - With NO_COLOR=1: no ANSI escape codes
6. Existing functionality unchanged (file viewing, discovery mode)
</verification>

<success_criteria>
- config validate follows Unix convention (quiet success, stderr errors)
- config validate checks source file existence
- config show displays effective config with colored output
- config show handles missing config gracefully with defaults
- NO_COLOR environment variable respected
</success_criteria>

<output>
After completion, create `.planning/phases/05-config-commands/05-02-SUMMARY.md`
</output>
