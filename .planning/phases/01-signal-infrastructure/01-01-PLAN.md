---
phase: 01-signal-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/signal.rs
  - src/capture.rs
  - src/source.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "Ctrl+C during capture mode cleans up marker before exit"
    - "SIGTERM during capture mode cleans up marker before exit"
    - "Double Ctrl+C forces immediate exit"
    - "Stale markers from SIGKILL are cleaned on next startup"
    - "Graceful shutdown exits with code 0"
    - "Force quit exits with code 1"
  artifacts:
    - path: "src/signal.rs"
      provides: "Shutdown flag setup using signal-hook::flag"
      exports: ["setup_shutdown_handlers"]
    - path: "src/source.rs"
      provides: "Stale marker cleanup function"
      exports: ["cleanup_stale_markers"]
  key_links:
    - from: "src/capture.rs"
      to: "src/signal.rs"
      via: "setup_shutdown_handlers() call"
      pattern: "signal::setup_shutdown_handlers"
    - from: "src/capture.rs"
      to: "loop exit"
      via: "shutdown_flag.load(Ordering::SeqCst)"
      pattern: "load\\(Ordering::SeqCst\\)"
    - from: "src/main.rs"
      to: "src/source.rs"
      via: "cleanup_stale_markers() at startup"
      pattern: "cleanup_stale_markers\\(\\)"
---

<objective>
Implement robust signal handling infrastructure for graceful shutdown with cleanup coordination.

Purpose: Fix the current capture.rs signal handler that bypasses cleanup by calling process::exit() directly. Add double Ctrl+C support for force-exit and stale marker recovery for SIGKILL scenarios.

Output: Signal handling module, refactored capture mode, stale marker cleanup
</objective>

<execution_context>
@/home/raay/.claude/get-shit-done/workflows/execute-plan.md
@/home/raay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-signal-infrastructure/01-CONTEXT.md
@.planning/phases/01-signal-infrastructure/01-RESEARCH.md

# Relevant source files
@src/capture.rs
@src/source.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create signal.rs module with shutdown infrastructure</name>
  <files>src/signal.rs, src/main.rs</files>
  <action>
Create a new `src/signal.rs` module that provides flag-based signal handling using `signal-hook::flag`.

Implementation:
1. Create `src/signal.rs` with:
   - `setup_shutdown_handlers() -> Result<Arc<AtomicBool>, std::io::Error>` function
   - Uses `signal_hook::consts::TERM_SIGNALS` (includes SIGINT, SIGTERM)
   - For each signal: register `register_conditional_shutdown(*sig, 1, Arc::clone(&term_now))` FIRST
   - Then register `register(*sig, Arc::clone(&term_now))` to arm the conditional shutdown
   - Returns the AtomicBool flag that becomes true when shutdown requested
   - The conditional shutdown makes second signal exit immediately with code 1

2. Add `mod signal;` to `src/main.rs` module declarations

Key pattern (from research):
```rust
use std::sync::Arc;
use std::sync::atomic::AtomicBool;
use signal_hook::consts::TERM_SIGNALS;
use signal_hook::flag;

pub fn setup_shutdown_handlers() -> Result<Arc<AtomicBool>, std::io::Error> {
    let term_now = Arc::new(AtomicBool::new(false));

    for sig in TERM_SIGNALS {
        // First: register conditional shutdown (exits with code 1 on second signal)
        flag::register_conditional_shutdown(*sig, 1, Arc::clone(&term_now))?;
        // Second: set term_now to true, arming the above for next signal
        flag::register(*sig, Arc::clone(&term_now))?;
    }

    Ok(term_now)
}
```

Important: Order matters - conditional_shutdown MUST be registered before the flag setter.
  </action>
  <verify>
- `cargo check` passes with new module
- `src/signal.rs` exists with `setup_shutdown_handlers` function
- `src/main.rs` has `mod signal;` declaration
  </verify>
  <done>
Signal module exists with flag-based shutdown handler that supports double Ctrl+C pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor capture.rs to use flag-based shutdown</name>
  <files>src/capture.rs</files>
  <action>
Refactor capture mode to use the new signal module instead of thread-based signal handling with process::exit().

Changes to `src/capture.rs`:
1. Remove the `thread::spawn` block with `Signals::iterator` (lines 56-67)
2. Remove unused imports: `signal_hook::iterator::Signals`, `thread`
3. Keep imports: `signal_hook::consts::{SIGINT, SIGTERM}` (or remove if using TERM_SIGNALS from signal.rs)
4. Import and use the new signal module: `use crate::signal::setup_shutdown_handlers;`

5. In `run_capture_mode()`:
   - Call `setup_shutdown_handlers()?` early (after marker creation)
   - Store the returned `Arc<AtomicBool>` as `shutdown_flag`
   - In the tee loop, check `shutdown_flag.load(Ordering::SeqCst)` to break
   - After loop exits (either EOF or signal), cleanup runs via normal control flow
   - Remove the `running` AtomicBool since it's replaced by shutdown_flag

6. The function structure becomes:
```rust
pub fn run_capture_mode(name: String) -> Result<()> {
    // 1-4: validation, ensure dirs, collision check, create marker (unchanged)

    // 5. Setup signal handlers (replaces thread spawn)
    let shutdown_flag = setup_shutdown_handlers()?;

    // 6-7: open log file, print header (unchanged)

    // 8. Tee loop with flag check
    for line in reader.lines() {
        if shutdown_flag.load(Ordering::SeqCst) {
            break;
        }
        // ... existing line processing ...
    }

    // 9. Cleanup on EOF or signal - now always reached
    remove_marker(&name)?;

    Ok(())
}
```

Important: Do NOT call process::exit() anywhere. Let the function return normally so cleanup runs via RAII and explicit remove_marker() call.
  </action>
  <verify>
- `cargo check` passes
- `cargo test` passes (existing capture tests)
- `cargo clippy` shows no warnings in capture.rs
- No `process::exit` calls in capture.rs (grep confirms)
- No `thread::spawn` for signal handling in capture.rs
  </verify>
  <done>
Capture mode uses flag-based shutdown, cleanup always runs on exit, double Ctrl+C forces immediate exit via conditional_shutdown
  </done>
</task>

<task type="auto">
  <name>Task 3: Add stale marker cleanup at startup</name>
  <files>src/source.rs, src/main.rs</files>
  <action>
Add stale marker detection and cleanup, called at application startup.

Changes to `src/source.rs`:
1. Add `cleanup_stale_markers() -> Result<()>` function:
```rust
/// Remove marker files for processes that are no longer running.
/// Called at startup to recover from SIGKILL scenarios.
/// Errors are logged to stderr but don't prevent startup.
pub fn cleanup_stale_markers() {
    let Some(sources) = sources_dir() else {
        return;
    };

    if !sources.exists() {
        return;
    }

    let entries = match std::fs::read_dir(&sources) {
        Ok(e) => e,
        Err(e) => {
            eprintln!("Warning: Could not read sources directory: {}", e);
            return;
        }
    };

    for entry in entries {
        let entry = match entry {
            Ok(e) => e,
            Err(_) => continue,
        };
        let path = entry.path();

        // Skip non-files
        if !path.is_file() {
            continue;
        }

        // Read PID from marker
        if let Some(pid) = read_marker_pid(&path) {
            // Only remove if process is definitely not running
            if !is_pid_running(pid) {
                // Remove silently - user doesn't need to know
                let _ = std::fs::remove_file(&path);
            }
        }
    }
}
```

Note: Function returns `()` not `Result` - errors are logged but don't prevent startup (per CONTEXT.md decisions).

Changes to `src/main.rs`:
1. In `fn main()`, after parsing args but before any mode dispatch, call:
```rust
// Cleanup stale markers from previous SIGKILL scenarios
source::cleanup_stale_markers();
```

2. This should happen early, around line 98 (after `let args = Args::parse();`)

The cleanup happens:
- Before capture mode (so collision check works correctly)
- Before discovery mode (so stale sources don't show as "active")
- Before normal file mode (doesn't hurt, keeps consistency)
  </action>
  <verify>
- `cargo check` passes
- `cargo test` passes
- `cargo clippy` shows no warnings
- Manual test: Create a marker file with a dead PID, run lazytail, marker should be removed
  </verify>
  <done>
Stale markers from SIGKILL are cleaned on startup before any mode runs
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build verification:**
   ```bash
   cargo build
   cargo test
   cargo clippy
   ```

2. **Functional verification (capture mode):**
   ```bash
   # Start capture mode
   yes "test line" | head -1000000 | cargo run -- -n test_signal &
   PID=$!
   sleep 1

   # Send SIGTERM - should exit gracefully, marker cleaned
   kill $PID
   sleep 1
   ls ~/.config/lazytail/sources/test_signal 2>/dev/null && echo "FAIL: marker exists" || echo "PASS: marker cleaned"
   ```

3. **Stale marker cleanup verification:**
   ```bash
   # Create a stale marker with dead PID
   mkdir -p ~/.config/lazytail/sources
   echo "99999999" > ~/.config/lazytail/sources/stale_test

   # Run lazytail (any mode that triggers cleanup)
   cargo run -- --help

   # Marker should be gone
   ls ~/.config/lazytail/sources/stale_test 2>/dev/null && echo "FAIL: stale marker exists" || echo "PASS: stale marker cleaned"
   ```

4. **Code verification:**
   ```bash
   # No process::exit in capture.rs
   grep -n "process::exit" src/capture.rs && echo "FAIL" || echo "PASS: no process::exit"

   # No thread spawn for signals in capture.rs
   grep -n "thread::spawn" src/capture.rs && echo "FAIL" || echo "PASS: no thread spawn"
   ```
</verification>

<success_criteria>
- [ ] `src/signal.rs` exists with `setup_shutdown_handlers()` function
- [ ] `src/capture.rs` uses flag-based signal handling (no process::exit)
- [ ] `src/source.rs` has `cleanup_stale_markers()` function
- [ ] `src/main.rs` calls `cleanup_stale_markers()` at startup
- [ ] All tests pass (`cargo test`)
- [ ] No clippy warnings (`cargo clippy`)
- [ ] Ctrl+C during capture mode cleans up marker
- [ ] SIGTERM during capture mode cleans up marker
- [ ] Stale markers are cleaned on startup
</success_criteria>

<output>
After completion, create `.planning/phases/01-signal-infrastructure/01-01-SUMMARY.md`
</output>
