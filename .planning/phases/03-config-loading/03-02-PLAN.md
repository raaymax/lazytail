---
phase: 03-config-loading
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/app.rs
  - src/main.rs
  - src/ui/mod.rs
  - src/tab.rs
autonomous: true

must_haves:
  truths:
    - "Config sources appear in side panel under Project Sources and Global Sources"
    - "Sources with missing files appear grayed out"
    - "Config parse errors show in debug source when viewer opens"
    - "Viewer opens normally even when config has errors"
  artifacts:
    - path: "src/app.rs"
      provides: "SourceType variants for config sources"
      contains: "ProjectSource"
    - path: "src/main.rs"
      provides: "Config loading and tab creation from sources"
      contains: "config::load"
    - path: "src/ui/mod.rs"
      provides: "Separate sections for project vs global sources"
      contains: "Project Sources"
  key_links:
    - from: "src/main.rs"
      to: "src/config/loader.rs"
      via: "calls load() after discovery"
      pattern: "config::load"
    - from: "src/main.rs"
      to: "src/tab.rs"
      via: "creates tabs from config sources"
      pattern: "TabState::from_config_source"
    - from: "src/ui/mod.rs"
      to: "src/app.rs"
      via: "renders SourceType::ProjectSource and GlobalSource"
      pattern: "SourceType::ProjectSource"
---

<objective>
Integrate config loading with main.rs and update UI to show config sources in separate groups.

Purpose: Make config sources visible and usable in the viewer with proper error handling.
Output: Config sources appear in side panel, errors display in debug source.
</objective>

<execution_context>
@/home/raay/.claude/get-shit-done/workflows/execute-plan.md
@/home/raay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-config-loading/03-CONTEXT.md
@.planning/phases/03-config-loading/03-01-SUMMARY.md
@src/main.rs
@src/app.rs
@src/ui/mod.rs
@src/tab.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add config source types and tab creation</name>
  <files>src/app.rs, src/tab.rs</files>
  <action>
1. Update SourceType enum in src/app.rs:
   ```rust
   #[derive(Debug, Clone, Copy, PartialEq, Eq)]
   pub enum SourceType {
       ProjectSource,  // NEW: From project lazytail.yaml
       GlobalSource,   // NEW: From global config.yaml
       Global,         // Discovered sources from -n capture (keep for backward compat)
       File,           // Files passed as CLI arguments
       Pipe,           // Stdin or pipe input
   }
   ```

2. Update tabs_by_category in src/app.rs to return 5 categories:
   ```rust
   pub fn tabs_by_category(&self) -> [(SourceType, Vec<usize>); 5] {
       let mut result = [
           (SourceType::ProjectSource, Vec::new()),
           (SourceType::GlobalSource, Vec::new()),
           (SourceType::Global, Vec::new()),
           (SourceType::File, Vec::new()),
           (SourceType::Pipe, Vec::new()),
       ];
       // ... populate based on tab.source_type()
   }
   ```

3. Update SourcePanelState.expanded array size from 3 to 5.

4. Add to src/tab.rs:
   ```rust
   /// Create tab from config source
   pub fn from_config_source(
       source: &config::Source,
       source_type: SourceType,
       watch: bool,
   ) -> Result<Self> {
       // If source doesn't exist, create disabled placeholder tab
       if !source.exists {
           return Self::disabled_source(source.name.clone(), source.path.clone(), source_type);
       }
       // Otherwise create normal file tab
       let mut tab = Self::new(source.path.clone(), watch)?;
       tab.name = source.name.clone();
       tab.config_source_type = Some(source_type);
       Ok(tab)
   }

   /// Create disabled tab for missing source (shown grayed out)
   fn disabled_source(name: String, path: PathBuf, source_type: SourceType) -> Result<Self> {
       // Create minimal tab that shows as disabled
       // ... implementation
   }
   ```

5. Add field to TabState to track config source type:
   ```rust
   pub config_source_type: Option<SourceType>,
   ```

6. Update source_type() method in TabState to check config_source_type first.
  </action>
  <verify>cargo check compiles without errors</verify>
  <done>SourceType has ProjectSource/GlobalSource, TabState can create tabs from config sources</done>
</task>

<task type="auto">
  <name>Task 2: Update UI for config source categories</name>
  <files>src/ui/mod.rs</files>
  <action>
Update render_sources_list in src/ui/mod.rs:

1. Update category name mapping:
   ```rust
   let cat_name = match cat {
       SourceType::ProjectSource => "Project Sources",
       SourceType::GlobalSource => "Global Sources",
       SourceType::Global => "Captured",  // Renamed for clarity
       SourceType::File => "Files",
       SourceType::Pipe => "Pipes",
   };
   ```

2. Handle disabled/missing sources:
   - Check if tab.source_exists (new field or check path)
   - If not exists: render name in DarkGray with strikethrough or dimmed
   - If not exists: skip the selectable behavior (can't open)

3. Update the expanded array indexing to handle 5 categories:
   ```rust
   let cat_idx = match cat {
       SourceType::ProjectSource => 0,
       SourceType::GlobalSource => 1,
       SourceType::Global => 2,
       SourceType::File => 3,
       SourceType::Pipe => 4,
   };
   let expanded = app.source_panel.expanded[cat_idx];
   ```

4. Ensure empty categories are skipped (no "Project Sources" header if no project sources).
  </action>
  <verify>cargo check compiles, UI renders correctly</verify>
  <done>Side panel shows separate sections for Project Sources and Global Sources</done>
</task>

<task type="auto">
  <name>Task 3: Integrate config loading in main.rs</name>
  <files>src/main.rs</files>
  <action>
Update main.rs to load config and create tabs from sources:

1. After discovery, load config:
   ```rust
   // Config discovery - run before mode dispatch
   let (discovery, searched_paths) = config::discovery::discover_verbose();
   // ... verbose output ...

   // Load config (Phase 3)
   let config_result = config::load(&discovery);
   let (config, config_errors) = match config_result {
       Ok(cfg) => (cfg, Vec::new()),
       Err(err) => (config::Config::default(), vec![err.to_string()]),
   };

   if args.verbose {
       if let Some(name) = &config.name {
           eprintln!("[config] Project name: {}", name);
       }
       eprintln!("[config] Project sources: {}", config.project_sources.len());
       eprintln!("[config] Global sources: {}", config.global_sources.len());
       if !config_errors.is_empty() {
           for err in &config_errors {
               eprintln!("[config] Error: {}", err);
           }
       }
   }
   ```

2. Before creating App, build tabs from config sources:
   ```rust
   let mut config_tabs = Vec::new();

   // Add project sources
   for source in &config.project_sources {
       match tab::TabState::from_config_source(source, SourceType::ProjectSource, watch) {
           Ok(tab) => config_tabs.push(tab),
           Err(e) => config_errors.push(format!("Failed to open {}: {}", source.name, e)),
       }
   }

   // Add global sources
   for source in &config.global_sources {
       match tab::TabState::from_config_source(source, SourceType::GlobalSource, watch) {
           Ok(tab) => config_tabs.push(tab),
           Err(e) => config_errors.push(format!("Failed to open {}: {}", source.name, e)),
       }
   }
   ```

3. In discovery mode, prepend config tabs:
   ```rust
   let mut tabs = config_tabs;
   tabs.extend(/* existing discovery tabs */);
   ```

4. In file mode, prepend config tabs:
   ```rust
   let mut tabs = config_tabs;
   tabs.extend(/* existing file/stdin tabs */);
   ```

5. Add --debug flag to Args (optional for this phase, could be Phase 5):
   - If config_errors not empty, log to stderr for now
   - Full debug source implementation can be deferred

Note: Keep backward compatibility - existing discovery mode and file mode still work.
  </action>
  <verify>cargo run -- with config file shows sources in panel, cargo run without config still works</verify>
  <done>Config sources loaded at startup and appear in viewer</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. `cargo test` passes
3. `cargo clippy` clean

Manual testing:
1. Create test config:
   ```yaml
   # ~/test-project/lazytail.yaml
   name: "Test Project"
   sources:
     - name: api
       path: /var/log/syslog
     - name: missing
       path: /nonexistent/file.log
   ```
2. Run `cd ~/test-project && lazytail`
3. Verify: "Project Sources" section visible in side panel
4. Verify: "api" source can be selected
5. Verify: "missing" source appears grayed out
6. Run `lazytail some.log` to verify file mode still works
7. Run `lazytail` (no config) to verify discovery mode still works
</verification>

<success_criteria>
- SourceType has ProjectSource and GlobalSource variants
- tabs_by_category returns 5 categories
- TabState::from_config_source creates tabs from config sources
- UI shows "Project Sources" and "Global Sources" sections
- Missing sources appear grayed/disabled
- Config errors logged to stderr (debug source deferred)
- Backward compatibility maintained
</success_criteria>

<output>
After completion, create `.planning/phases/03-config-loading/03-02-SUMMARY.md`
</output>
