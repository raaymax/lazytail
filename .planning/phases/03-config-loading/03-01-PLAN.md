---
phase: 03-config-loading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/config/mod.rs
  - src/config/types.rs
  - src/config/loader.rs
  - src/config/error.rs
autonomous: true

must_haves:
  truths:
    - "YAML config with name and sources fields parses correctly"
    - "Unknown fields cause parse errors with suggestions"
    - "Tilde paths expand to home directory"
    - "Parse errors include file path, line number, and suggestion"
  artifacts:
    - path: "src/config/types.rs"
      provides: "Config structs with deny_unknown_fields"
      contains: "deny_unknown_fields"
    - path: "src/config/loader.rs"
      provides: "YAML parsing and config loading"
      contains: "serde_saphyr::from_str"
    - path: "src/config/error.rs"
      provides: "ConfigError with location and suggestions"
      contains: "jaro_winkler"
  key_links:
    - from: "src/config/loader.rs"
      to: "src/config/types.rs"
      via: "imports Config structs for parsing"
      pattern: "use.*types::"
    - from: "src/config/loader.rs"
      to: "src/config/error.rs"
      via: "returns ConfigError on failure"
      pattern: "ConfigError"
---

<objective>
Create config loading infrastructure: YAML parsing with serde-saphyr, strict validation with typo suggestions, and tilde path expansion.

Purpose: Enable loading and validating lazytail.yaml and global config files with helpful error messages.
Output: Config module with types.rs, loader.rs, and error.rs ready for main.rs integration.
</objective>

<execution_context>
@/home/raay/.claude/get-shit-done/workflows/execute-plan.md
@/home/raay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-config-loading/03-CONTEXT.md
@.planning/phases/03-config-loading/03-RESEARCH.md
@.planning/phases/02-config-discovery/02-01-SUMMARY.md
@src/config/mod.rs
@src/config/discovery.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create config types</name>
  <files>Cargo.toml, src/config/types.rs, src/config/mod.rs</files>
  <action>
1. Add dependencies to Cargo.toml:
   - serde-saphyr = "0.0" (YAML parsing, NOT serde-yaml which is unmaintained)
   - strsim = "0.11" (string similarity for suggestions)
   - thiserror = "1.0" (error derivation)

2. Create src/config/types.rs with:
   ```rust
   use serde::Deserialize;
   use std::path::PathBuf;

   /// Raw config file structure (used for parsing)
   #[derive(Debug, Deserialize)]
   #[serde(deny_unknown_fields)]
   pub struct RawConfig {
       pub name: Option<String>,
       #[serde(default)]
       pub sources: Vec<RawSource>,
   }

   /// Raw source from config file
   #[derive(Debug, Deserialize)]
   #[serde(deny_unknown_fields)]
   pub struct RawSource {
       pub name: String,
       pub path: PathBuf,
   }

   /// Validated source with expanded path and existence check
   #[derive(Debug, Clone)]
   pub struct Source {
       pub name: String,
       pub path: PathBuf,
       pub exists: bool,
   }

   /// Merged config from global and project files
   #[derive(Debug, Clone, Default)]
   pub struct Config {
       pub name: Option<String>,
       pub project_sources: Vec<Source>,
       pub global_sources: Vec<Source>,
   }

   impl Config {
       pub fn has_sources(&self) -> bool {
           !self.project_sources.is_empty() || !self.global_sources.is_empty()
       }
   }
   ```

3. Update src/config/mod.rs to export new modules:
   ```rust
   pub mod discovery;
   pub mod error;
   pub mod loader;
   pub mod types;

   pub use discovery::{discover, discover_verbose, DiscoveryResult};
   pub use error::ConfigError;
   pub use loader::load;
   pub use types::{Config, Source};
   ```
  </action>
  <verify>cargo check compiles without errors</verify>
  <done>Config types defined with deny_unknown_fields, dependencies added</done>
</task>

<task type="auto">
  <name>Task 2: Create error module with suggestions</name>
  <files>src/config/error.rs</files>
  <action>
Create src/config/error.rs with ConfigError that includes:
- File path where error occurred
- Line/column location from serde-saphyr
- "Did you mean" suggestion for unknown fields
- Cargo-style Display formatting

Key implementation details:
1. Use strsim::jaro_winkler with 0.8 threshold for suggestions
2. Known fields for root config: ["name", "sources"]
3. Known fields for source: ["name", "path"]
4. Extract unknown field name from serde error message using regex or string parsing
5. Include thiserror for clean error derivation

The error should format like:
```
error: unknown field `nam` at line 1 column 1
  --> /path/to/config.yaml:1:1
  |
  = help: did you mean `name`?
```

Handle these error variants:
- IoError: File read failures
- ParseError: YAML syntax errors
- ValidationError: Semantic errors (e.g., empty source name)
  </action>
  <verify>cargo check compiles, error formatting matches expected style</verify>
  <done>ConfigError with location info, suggestions, and Cargo-style formatting</done>
</task>

<task type="auto">
  <name>Task 3: Create config loader with path expansion</name>
  <files>src/config/loader.rs</files>
  <action>
Create src/config/loader.rs with:

1. `expand_path(path: &Path) -> PathBuf` function:
   - Handle tilde: `~/foo` -> `/home/user/foo`
   - Use dirs::home_dir() (already in project)
   - Pass through absolute paths unchanged

2. `load_file(path: &Path) -> Result<RawConfig, ConfigError>`:
   - Read file content
   - Parse with serde_saphyr::from_str
   - Wrap errors with ConfigError including suggestions

3. `validate_sources(raw: Vec<RawSource>) -> Vec<Source>`:
   - Expand paths with expand_path
   - Check file existence with try_exists()
   - Return validated Sources with exists flag

4. `load(discovery: &DiscoveryResult) -> Result<Config, ConfigError>`:
   - Load project config if discovery.project_config exists
   - Load global config if discovery.global_config exists
   - Merge: name from project, sources in separate groups
   - Return empty Config if no configs exist (graceful degradation)

5. Unit tests:
   - Test expand_path with tilde and absolute paths
   - Test load with missing files (returns empty Config)
   - Test load with valid YAML
   - Test unknown field detection
  </action>
  <verify>cargo test config::loader passes, cargo clippy clean</verify>
  <done>Config loader parses YAML, expands paths, validates sources, merges configs</done>
</task>

</tasks>

<verification>
1. `cargo build` succeeds
2. `cargo test` passes (including new config loader tests)
3. `cargo clippy` has no warnings
4. Manual test: Create test config and verify parsing
   ```yaml
   # /tmp/test-config.yaml
   name: "Test Project"
   sources:
     - name: api
       path: ~/logs/api.log
   ```
</verification>

<success_criteria>
- serde-saphyr, strsim, thiserror added to Cargo.toml
- Config types with deny_unknown_fields in types.rs
- ConfigError with suggestions and location in error.rs
- Config loader with path expansion in loader.rs
- Unit tests for loader functions
- No clippy warnings
</success_criteria>

<output>
After completion, create `.planning/phases/03-config-loading/03-01-SUMMARY.md`
</output>
